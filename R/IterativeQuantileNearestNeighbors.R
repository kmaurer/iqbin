
#--------------------------------------
#' Iterative Quantile Binned Nearest Neighbors
#'
#' @description Function for creating iterative quantile nearest neighbors model. Bin the training data, then store the binning definitions and bin statistics to be used to estimate for future testing data.
#'
#' @param data Data frame containing the response variable and numeric input variables from the training data
#' @param y Name of response variable column
#' @param mod_type Depends on response variables type: "reg" creates iqnn-regression for predicting numeric values, "class" creates iqnn-classifier for predicting categorical values
#' @param bin_cols vector of column names of variables to iteratively bin, ordered first to last
#' @param nbins vector of number of bins per step of iterative binning, ordered first to last
#' @param jit vector of margins for uniform jitter to each dimension to create seperability of tied obs due to finite precision
#' @param stretch TRUE/FALSE if will bins be given tolerance buffer
#' @param tol vector of tolerance values to stretch each dimension for future binning
#' 
#' @return list containing binned training data, binning definition, and bin statistics
#' @examples 
#' iqnn_mod <- iqnn(data=iris, y="Species", mod_type="class", bin_cols=c("Sepal.Length","Sepal.Width","Petal.Width"),
#'                  nbins=c(3,5,2), jit=rep(0.001,3), tol = rep(0.001,3))
#' str(iqnn_mod)                

iqnn <- function(data, y, mod_type="reg", bin_cols, nbins, jit = rep(0,length(bin_cols)), stretch=FALSE, tol = rep(0,length(bin_cols)) ){
  data <- as.data.frame(data)
  iq_bin <- iterative_quant_bin(data, bin_cols, nbins, output="both",jit)
  if(stretch) iq_bin <- stretch_iq_bins(iq_bin, tol=tol)
  iq_bin$bin_def$y <- y
  total_bins = nrow(iq_bin$bin_def$bin_centers)
  if(mod_type=="reg"){
    iq_bin$bin_def$bin_stats <- data.frame(pred = sapply(1:total_bins, function(b) mean(data[iq_bin$bin_data$bin_data$bin_index==b,y], na.rm=TRUE)),
                                           obs = sapply(1:total_bins, function(b) sum(iq_bin$bin_data$bin_data$bin_index==b)) )
  }else if(mod_type=="class"){
    iq_bin$bin_def$bin_stats <- data.frame(pred = sapply(1:total_bins, function(b) majority_vote(data[iq_bin$bin_data$bin_data$bin_index==b,y])),
                                           obs = sapply(1:total_bins, function(b) sum(iq_bin$bin_data$bin_data$bin_index==b)) )
  }else{return(print("mod_type must be either 'reg' or 'class'"))}
  return(iq_bin$bin_def)
}

#--------------------------------------
#' Predict for test data using iqnn model
#'
#' @description New observations selected from the same population as the data used to build bin definitions may fall just outside the bins. If we wish to include nearby values we can either allow outer bins to be extended (this function) or to leave the outer bins unbounded.
#'
#' @param iqnn_mod iterative quantile nearest neighbors model generated by the iqnn function
#' @param test_data Data frame of test data to estimate response values for
#' @param type output "estimate", "binsize", or "both"
#' @param strict TRUE/FALSE: If TRUE Observations must fall within existing bins to be assigned; if FALSE the outer bins in each dimension are unbounded to allow outlying values to be assigned.
#' 
#' @return predicted responses, number of neighbors or both
#' @examples 
#' # Test Regression
#' test_index <- c(1,2,51,52,101,102)
#' iqnn_mod <- iqnn(iris[-test_index,], y="Petal.Length", bin_cols=c("Sepal.Length","Sepal.Width","Petal.Width"),
#'                  nbins=c(3,5,2), jit=rep(0.001,3), stretch=TRUE, tol=rep(.2,3))
#' test_data <- iris[test_index,]
#' predict_iqnn(iqnn_mod, test_data,strict=FALSE)
#' predict_iqnn(iqnn_mod, test_data,strict=TRUE)
#' predict_iqnn(iqnn_mod, test_data,type="both")
#' 
#' # Test Classifier
#' iqnn_mod <- iqnn(data=iris[-test_index,], y="Species", mod_type="class", bin_cols=c("Sepal.Length","Sepal.Width","Petal.Width"),
#'                  nbins=c(3,5,2), jit=rep(0.001,3), tol = rep(0.001,3))
#' test_data <- iris[test_index,]
#' predict_iqnn(iqnn_mod, test_data,strict=FALSE)
#' predict_iqnn(iqnn_mod, test_data,type="both",strict=FALSE)

predict_iqnn <- function(iqnn_mod,test_data, type="estimate",strict=FALSE){
  test_data <- as.data.frame(test_data)
  #!# has bugs when strict=TRUE
  test_bin <- bin_by_iq_def(iqnn_mod, test_data, output="data",strict=strict)
  if(type=="estimate") return(iqnn_mod$bin_stats$pred[test_bin$bin_indeces])
  if(type=="binsize") return(iqnn_mod$bin_stats$obs[test_bin$bin_indeces])
  if(type=="both") return(iqnn_mod$bin_stats[test_bin$bin_indeces,])
}

#--------------------------------------
#' Cross Validated predictions for iqnn models
#'
#' @description Cross-validate an iqnn specification using k-fold scheme on given data
#'
#' @param data Data frame containing the response variable and numeric input variables from the training data
#' @param y Name of response variable column
#' @param mod_type Depends on response variables type: "reg" creates iqnn-regression for predicting numeric values, "class" creates iqnn-classifier for predicting categorical values
#' @param bin_cols vector of column names of variables to iteratively bin, ordered first to last
#' @param nbins vector of number of bins per step of iterative binning, ordered first to last
#' @param jit vector of margins for uniform jitter to each dimension to create seperability of tied obs due to finite precision
#' @param stretch TRUE/FALSE if will bins be given tolerance buffer
#' @param tol vector of tolerance values to stretch each dimension for future binning
#' @param strict TRUE/FALSE: If TRUE Observations must fall within existing bins to be assigned; if FALSE the outer bins in each dimension are unbounded to allow outlying values to be assigned.
#' @param cv_k integer specifying number of folds
#' 
#' @return cross validated predicted responses for all observations in data
#' @examples 
# cv_preds <- cv_pred_iqnn(data=iris, y="Species",mod_type="class", bin_cols=c("Sepal.Length","Sepal.Width","Petal.Width"),
#              nbins=c(3,5,2), jit=rep(0.001,3), strict=FALSE, cv_k=10)
# table(cv_preds, iris$Species)

cv_pred_iqnn <- function(data, y, mod_type="reg", bin_cols, nbins, jit=rep(0,length(bin_cols)), stretch=FALSE, tol=rep(0,length(bin_cols)), strict=FALSE, cv_k=10){
  data <- as.data.frame(data)
  cv_cohorts <- make_cv_cohorts(data, cv_k)
  cv_preds <- rep(NA,nrow(data))
  for(fold in 1:length(unique(cv_cohorts))){
    test_index <- which(cv_cohorts==fold)
    train_data_temp <- data[-test_index,]
    row.names(train_data_temp) <- 1:nrow(train_data_temp)
    iqnn_mod <- iqnn(train_data_temp, y=y, mod_type=mod_type, bin_cols=bin_cols, 
                     nbins=nbins, jit=jit,stretch=stretch, tol=tol)
    cv_preds[test_index] <- predict_iqnn(iqnn_mod, data[test_index,],strict=strict, type="estimate")
  }
  if(mod_type=="class") cv_preds <- factor(cv_preds, labels=levels(data[,y]))
  cv_preds
}

#--------------------------------------
#' Tuning function for iqnn model
#'
#' @description Identify optimal number of bins per dimension for iterative quantile nearest-neighbor model using k-fold cross validation
#'
#' @param data Data frame containing the response variable and numeric input variables from the training data
#' @param y Name of response variable column
#' @param mod_type Depends on response variables type: "reg" creates iqnn-regression for predicting numeric values, "class" creates iqnn-classifier for predicting categorical values
#' @param bin_cols vector of column names of variables to iteratively bin, ordered first to last
#' @param nbin_range positive integer vector containing lower and upper bounds on number of bins in each dimension
#' @param jit vector of margins for uniform jitter to each dimension to create seperability of tied obs due to finite precision
#' @param stretch TRUE/FALSE if will bins be given tolerance buffer
#' @param tol vector of tolerance values to stretch each dimension for future binning
#' @param strict TRUE/FALSE: If TRUE Observations must fall within existing bins to be assigned; if FALSE the outer bins in each dimension are unbounded to allow outlying values to be assigned.
#' @param cv_k integer specifying number of folds
#' 
#' @return data frame with one row per binning specification with desriptive and performance statistics: bin dimensitions, number of bins, equivalent k-nearest neightbor size, performance (mean squared error or class error rate)
#' @examples 
#' # 10-fold CV
#' cv_tune1 <- tune_iqnn(data=iris, y="Petal.Length", bin_cols=c("Sepal.Length","Sepal.Width","Petal.Width"),
#'                       nbins_range=c(2,5), jit=rep(0.001,3), strict=FALSE, cv_k=10)
#' cv_tune1
#' # LOO CV
#' cv_tune2 <- tune_iqnn(data=iris, y="Petal.Length", bin_cols=c("Sepal.Length","Sepal.Width","Petal.Width"),
#'                       nbins_range=c(2,5), jit=rep(0.001,3), strict=FALSE, cv_k=nrow(iris))
#' cv_tune2

tune_iqnn <- function(data, y, mod_type="reg", bin_cols, nbins_range, jit=rep(0,length(bin_cols)), stretch=FALSE, tol=rep(0,length(bin_cols)), strict=FALSE, cv_k=10){
  nbins_list <- make_nbins_list(nbins_range,length(bin_cols))
  cv_results <- data.frame(bin_dims = sapply(nbins_list, function(x) paste(x,collapse="X")))
  for(t in 1:length(nbins_list)){
    cv_preds <- cv_pred_iqnn(data, y, mod_type=mod_type, bin_cols, nbins_list[[t]], jit, stretch, tol, strict, cv_k)
    if(mod_type=="reg") cv_results$MSE[t] <- mean((data[,y]-cv_preds)^2)
    if(mod_type=="class") cv_results$error[t] <- sum(cv_preds!=dat[,y_name]) / nrow(dat)
    cv_results$nbins_total[t] <- prod(nbins_list[[t]])
    cv_results$nn_equiv[t] <- (cv_k-1)/cv_k*nrow(data)/prod(nbins_list[[t]])
  }
  if(mod_type=="reg") cv_results$RMSE <- sqrt(cv_results$MSE)
  return(cv_results)
}
